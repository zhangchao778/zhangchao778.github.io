<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AWS总结]]></title>
    <url>%2F2019%2F07%2F17%2FAWS%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[EC2 EC2实例类型选择考虑因素 核心数量 内存大小 存储大小和类型 网络性能 CPU技术 实例 实例系列 部分使用案例 通用型（T2、T3、M5、M4） 低流量网站和Web应用程序中小型数据库 计算优化型（C5、C4） 高性能Web服务器视频编码 内存优化型（X1e、X1、R4） 高性能数据库份额不是内存缓存 存储优化型（H1、I3、D2） 数据仓库日志或数据处理应用程序 加速计算型（P3、P2、G3、F1） 3D可视化机器学习 S3 ​ 面向Internet的存储服务，原生在线、Http访问，随时从Web的任何位置存储和检索任意数量的数据。高度可扩展、可靠、快速且持久。 使用场景 一次写多次读的场景 存储和备份 访问控制 默认访问(只能自己访问) 公有访问(自己以及其他人可以访问) 特点 S3将数据以对象的形式存储在存储桶中 设计为99.999999999%的持久性 可以控制对存储桶及其对象的访问 对象由文件和元数组组成 每个账户最多可以包含100个存储桶 （桶是为了管理） 存储桶内对象个数没有限制 可启用静态加密和动态加密 （信封加密 ） 对象可以提供URL访问 http://johnsmith.s3.amazonaws.com/photos/puppy.jpg johnsmith —存储桶 puppy–对象主键 存储桶 在最高级别组织Amazon S3命令空间 识别负责存储和数据传输计费的账户 在访问控制方面发挥作用 用作使用率报告的汇总单位 存储桶名称是全球唯一的 S3存储类 存储类 持久性 可用性 其他注意事项 Amazon S3标准 99.999999999% 99.99% 存贵，取便宜 Amazon S3标准-不频繁访问(IA) 99.999999999% 99.9% 对象具有检索费用最适合不频繁访问的数据存便宜,取贵 Glacier 99.999999999% 99.99%(还原后) 无法进行实时访问必须先还原对象,然后才能访问对象还原对象需要花费1分钟到12小时 弹性（高可用）和恢复能力 Auto Scaling 场景 自动扩展EC2容量，非常适用使用率不断变化的应用程序 三重服务 Auto Scaling组Auto Scaling组中的实例被视为一个逻辑组以便进行实例扩展和管理 Auto Scaling基本生命周期 ELB(Elastic Load Balance) 功能 在多个实例间分配流量 支持运行状况检查,可检测出运行不正常的Amazon EC2实例 支持Amazon EC2实例的HTTP、HTTPS和TCP流量的路由和负载均衡 工作原理 CloudWatch 功能 适用于AWS云资源和AWS上运行的应用程序的监控服务,提供图形化的统计数据,设置报警 了解资源利用率、运行性能和整体需求模式 自定义自己的应用程序特定指标 可通过AWS管理控制台、API、软件开发工具包或CLI访问 架构]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA激活]]></title>
    <url>%2F2019%2F07%2F01%2FIDEA%E6%BF%80%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[IDEA激活 1.补丁网盘自取 链接: https://pan.baidu.com/s/16rQPgO0ypNAvAamxYtS5ww 提取码: k25q 2.配置 补丁copy至idea安装目录的bin目录下 bin目录中找到idea.exe.vmoptions和idea64.exe.vmoptions两个文件,在文件最后追加一行内容：-javaagent:idea安装路径\bin\JetbrainsCrack-release-enc.jar 3.激活 打开IDEA，选择激活码激活,激活码如下 123456789101112131415161718192021222324ThisCrackLicenseId-&#123;“licenseId”:”11011”,“licenseeName”:”Wechat”,“assigneeName”:”tree-deep-see-deer”,“assigneeEmail”:”2378437815@qq.com”,“licenseRestriction”:””,“checkConcurrentUse”:false,“products”:[&#123;“code”:”II”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”DM”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”AC”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”RS0”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”WS”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”DPN”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”RC”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”PS”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”DC”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”RM”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”CL”,”paidUpTo”:”2099-12-31”&#125;,&#123;“code”:”PC”,”paidUpTo”:”2099-12-31”&#125;],“hash”:”2911276/0”,“gracePeriodDays”:7,“autoProlongated”:false&#125;]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Swagger2]]></title>
    <url>%2F2019%2F04%2F17%2FSpringBoot%E6%95%B4%E5%90%88Swagger2%2F</url>
    <content type="text"><![CDATA[​ 如何构建一份合理高效的接口文档很重要，Swagger的出现可以完美解决了传统接口管理方式存在的痛点。以下介绍Spring Boot整合Swagger2的流程，连带填坑。 SpringBoot整合Swagger2 引入相应的maven包1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt; 编写Swagger2的配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.swagger.demo.config;import io.swagger.annotations.Api;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * @author Mr.zhang * @description swagger配置类 * @date 9:06 AM 2019/4/17 */@Configuration@EnableSwagger2public class Swagger2Config &#123; @Value("$&#123;swagger2.enable&#125;") private boolean enable; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .groupName("Demo模块") .select() .apis(RequestHandlerSelectors.withClassAnnotation(Api.class)) .paths(PathSelectors.regex("/demo.*")) .build() .apiInfo(apiInfo()) .enable(enable); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("Demo模块接口文档") .description("提供Demo模块文档") .termsOfServiceUrl("https://xingtian.github.io/trace.github.io/") .version("1.0") .build(); &#125;&#125; ​ 注解@EnableSwagger2开启swagger2,apiInfo是接口文档的基本说明信息，包括标题、描述、服务网址、联系人、版本等信息。 ​ Docket创建，通过groupName进行分组，paths属性进行过滤，apis属性可以设置扫描包，或者通过注解的方式标识。 ​ enable属性主要用于控制是否生成接口文档，比如：生产环境不生成接口文档。 Controller层类和方法添加相关注解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.swagger.demo.web;import com.swagger.demo.entity.ResultModel;import com.swagger.demo.entity.User;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;import org.springframework.web.bind.annotation.*;import java.util.ArrayList;import java.util.List;/** * @author Mr.zhang * @description Demo控制层 * @date 9:57 AM 2019/4/17 */@RestController@RequestMapping("/demo")@Api(tags = "demo模块")public class DemoController &#123; @GetMapping("/query/&#123;id&#125;") @ApiOperation("通过ID查询") @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "int", paramType = "path") public ResultModel&lt;User&gt; findById(@PathVariable int id) &#123; return ResultModel.success("id查询成功", new User()); &#125; @GetMapping("/query/ids") @ApiOperation("通过ID列表查询") public ResultModel&lt;List&lt;User&gt;&gt; findByIdIn(int[] ids) &#123; return ResultModel.success("in查询成功", new ArrayList&lt;&gt;()); &#125; @GetMapping("/query/user") @ApiOperation("通过用户实体查询") public ResultModel&lt;List&lt;User&gt;&gt; findByUser(User user) &#123; return ResultModel.success("通过实体查询成功", new ArrayList&lt;&gt;()); &#125; @GetMapping("/query/all") @ApiOperation("查询所有用户") public ResultModel&lt;List&lt;User&gt;&gt; findAll() &#123; return ResultModel.success("全体查找成功", new ArrayList&lt;&gt;()); &#125; @GetMapping("/query/username") @ApiOperation("通过用户名称模糊查询") @ApiImplicitParam(name = "userName", value = "用户名称") public ResultModel&lt;List&lt;User&gt;&gt; findByUserName(String userName) &#123; return ResultModel.success(new ArrayList&lt;&gt;()); &#125; @PostMapping("/insert") @ApiOperation("新增默认用户") public ResultModel&lt;Integer&gt; insert() &#123; User user = new User(); user.setUserName("zhongshiwen"); user.setNickName("zsw"); user.setRealName("钟仕文"); user.setPassword("zsw123456"); user.setGender("男"); return ResultModel.success("新增用户成功", user.getId()); &#125; @PutMapping("/update") @ApiOperation("更新用户信息") public ResultModel&lt;Integer&gt; update(User user) &#123; return ResultModel.success(user.getId()); &#125; @PutMapping("/update/status") @ApiOperation("更新单个用户状态") @ApiImplicitParams(&#123; @ApiImplicitParam(name = "id", value = "用户ID", required = true), @ApiImplicitParam(name = "status", value = "状态", required = true) &#125;) public ResultModel&lt;User&gt; updateStatus(int id, byte status) &#123; return ResultModel.success(new User()); &#125; @DeleteMapping("/delete") @ApiOperation("删除单个用户") @ApiImplicitParam(value = "用户ID", required = true) public ResultModel&lt;Integer&gt; delete(int id) &#123; return ResultModel.success(id); &#125;&#125; 返回对象ResultModel12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.swagger.demo.entity;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;/** * @author Mr.zhang * @description 返回对象 * @date 10:00 AM 2019/4/17 */@ApiModel(description = "返回结果")@Datapublic final class ResultModel&lt;T&gt; &#123; @ApiModelProperty("是否成功: true or false") private boolean result; @ApiModelProperty("描述性原因") private String message; @ApiModelProperty("业务数据") private T data; private ResultModel(boolean result, String message, T data) &#123; this.result = result; this.message = message; this.data = data; &#125; public static&lt;T&gt; ResultModel&lt;T&gt; success(T data) &#123; return new ResultModel&lt;&gt;(true, "SUCCESS", data); &#125; public static&lt;T&gt; ResultModel&lt;T&gt; success(String message, T data) &#123; return new ResultModel&lt;&gt;(true, message, data); &#125; public static ResultModel failure() &#123; return new ResultModel&lt;&gt;(false, "FAILURE", null); &#125; public static ResultModel failure(String message) &#123; return new ResultModel&lt;&gt;(false, message, null); &#125;&#125; ApiModel属性对象1234567891011121314151617181920212223242526272829303132333435363738package com.swagger.demo.entity;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.time.LocalDate;import java.time.LocalDateTime;/** * @author Mr.zhang * @description 用户表实体 * @date 10:03 AM 2019/4/17 */@Data@NoArgsConstructor@AllArgsConstructor@ApiModelpublic class User &#123; @ApiModelProperty("用户ID") private Integer id; @ApiModelProperty("账户名") private String userName; @ApiModelProperty("用户昵称") private String nickName; @ApiModelProperty("真实姓名") private String realName; @ApiModelProperty("身份证号码") private String identityCard; @ApiModelProperty("性别") private String gender; @ApiModelProperty("出生日期") private LocalDate birth; @ApiModelProperty("手机号码") private String phone; @ApiModelProperty("邮箱") private String email; @ApiModelProperty("密码") private String password; @ApiModelProperty("用户头像地址") private String logo; @ApiModelProperty("账户状态 0:正常; 1:冻结; 2:注销") private Byte status; @ApiModelProperty("个性签名") private String summary; @ApiModelProperty("用户所在区域码") private String areaCode; @ApiModelProperty("注册时间") private LocalDateTime registerTime; @ApiModelProperty("最近登录时间") private LocalDateTime lastLoginTime;&#125; Swagger2几个重要注解 @Api：用在请求的类上，表示对类的说明 tags “说明该类的作用，可以在UI界面上看到的注解” value “该参数没什么意义，在UI界面上也看到，所以不需要配置” @ApiOperation：用在请求的方法上，说明方法的用途、作用 value=”说明方法的用途、作用” notes=”方法的备注说明” @ApiImplicitParams：用在请求的方法上，表示一组参数说明 @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面 value：参数的汉字说明、解释 required：参数是否必须传 paramType： 参数放在哪个地方 1.header –&gt; 请求参数的获取：@RequestHeader 2.query –&gt; 请求参数的获取：@RequestParam 3.path（用于restful接口）–&gt; 请求参数的获取：@PathVariable 4.body（不常用） 5.form（不常用） dataType：参数类型，默认String，其它值dataType=”Integer” defaultValue：参数的默认值 @ApiResponses：用在请求的方法上，表示一组响应 @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息 code：数字，例如400 message：信息，例如”请求参数没填好” response：抛出异常的类 @ApiModel：主要有两种用途： 用于响应类上，表示一个返回响应数据的信息 入参实体：使用@RequestBody这样的场景， 请求参数无法使用@ApiImplicitParam注解进行描述的时候 @ApiModelProperty：用在属性上，描述响应类的属性 最终呈现结果 启动应用后，会自动生成页面地址：http://{root-path}/swagger-ui.html（http://localhost:8080/swagger-ui.html） 效果如下： 利用该文档可以在线测试接口]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 私服]]></title>
    <url>%2F2019%2F04%2F15%2FDocker%20%20%E7%A7%81%E6%9C%8D%2F</url>
    <content type="text"><![CDATA[Harbor搭建Docker 私服https://blog.51cto.com/11093860/2117805 1.安装docker-compose 1sudo pip install docker-compose 2.下载Harbor包 https://github.com/vmware/harbor/releases 安装有两种方式，一种是off-line ，一种是on-line，即离线和在线安装，离线安装需要下载的安装包较大，在线安装下载的安装包很小，课题根据自己的情况选择 3.解压，进入安装包 12tar -zxvf harbor*.tgzcd harbor 4.修改配置文件 1vim docker-compose.yml 1vim harbor.cfg 5.执行./prepare,更新一下配置文件 1sudo ./prepare 6.执行./install.sh，开始安装并启动 1sudo ./install.sh 7.在火狐浏览器中访问测试，此处的用户名默认为admin，密码在habor.cfg中，可以自己设 地址 IP/harbor/sign-in/]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis实现分布式锁]]></title>
    <url>%2F2019%2F03%2F28%2FRedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[分布式锁的实现方案 Spring早就提供了分布式锁的实现，早期，分布式锁的相关代码存在与Spring Cloud的子项目Spring Cloud Cluster中，后来被迁移到了Spring Integration中。 ​ Spring Cloud Cluster的GitHub：https://github.com/spring-cloud/spring-cloud-cluster/ ​ Spring Integration的GitHub：https://github.com/spring-projects/spring-integration/ 官方对于Spring Integration的说法是 这是一个企业集成模式的实现。Spring Cloud Stream的底层也是Spring Integration。 Spring Integration提供了多种全局锁，现在我们在这里只介绍基于Redis的分布式锁 基于Spring Integration 实现Redis的分布式锁 1.依赖 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-integration&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt; &lt;artifactId&gt;spring-integration-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2.Redis配置 1234spring: redis: port: 6379 host: localhost 3.RedisLock初始化 1234567@Configurationpublic class RedisLockConfiguration &#123; @Bean public RedisLockRegistry redisLockRegistry(RedisConnectionFactory redisConnectionFactory) &#123; return new RedisLockRegistry(redisConnectionFactory, "RedisLockRegistry"); &#125;&#125; ​ org.springframework.integration.redis.util.RedisLockRegistry的注释详细描述了该类的特性以及使用方式。 4.测试代码 12345678910111213141516171819202122232425262728/** * @author Mr.zhang * @description * @date 1:43 PM 2019/3/26 */@Slf4j@RestController@RequestMapping("redisLock")public class RedisLockController &#123; @Autowired private RedisLockRegistry redisLockRegistry; @GetMapping("test") public void test() throws InterruptedException &#123; Lock lock = redisLockRegistry.obtain("redisLock"); boolean b1 = lock.tryLock(3, TimeUnit.SECONDS); log.info("b1 is : &#123;&#125;", b1); TimeUnit.SECONDS.sleep(5); boolean b2 = lock.tryLock(3, TimeUnit.SECONDS); log.info("b2 is : &#123;&#125;", b2); lock.unlock(); lock.unlock(); &#125;&#125; 启动1个实例,访问 http://localhost:8080/redisLock/test ，会看到类似如下的日志 122019-03-26 14:42:28.206 INFO 4913 --- [nio-8080-exec-1] c.r.lock.controller.RedisLockController : b1 is : true2019-03-26 14:42:33.212 INFO 4913 --- [nio-8080-exec-1] c.r.lock.controller.RedisLockController : b2 is : true 启动2个实例，并迅速访问两个实例的 /test 端点，会在第二个实例上看到类似如下日志 12345678[nio-8081-exec-1] c.r.lock.controller.RedisLockController : b1 is : false[nio-8081-exec-1] c.r.lock.controller.RedisLockController : b2 is : true[nio-8081-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() ...java.lang.IllegalStateException: You do not own lock at RedisLockRegistry:redisLock at org.springframework.integration.redis.util.RedisLockRegistry$RedisLock.unlock(RedisLockRegistry.java:300) ~[spring-integration-redis-5.1.3.RELEASE.jar!/:5.1.3.RELEASE] at com.redis.lock.controller.RedisLockController.test(RedisLockController.java:38) ~[classes!/:0.0.1-SNAPSHOT] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_144] ​ 说明第二个实例没有拿到锁，证明了分布式锁的存在 参考地址]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合RabbitMQ]]></title>
    <url>%2F2019%2F03%2F27%2FSpringBoot%20%E6%95%B4%E5%90%88%20RabbitMQ%2F</url>
    <content type="text"><![CDATA[RabbitMQ支持持久化（MQ down或者MQ所在的服务器down了，消息不会丢失的机制） 整合步骤 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 配置 123456spring: rabbitmq: host: 10.0.96.102 # MQ部署IP port: 5672 # MQ应用端口 不是web端口 username: admin password: admin]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ 安装]]></title>
    <url>%2F2019%2F03%2F27%2FRabbitMQ%20%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装 ​ 由于RabbitMQ是基于Erlang语言开发，所以在安装RabbitMQ之前，需要先安装Erlang，RabbitMQ官网已经为我们提供了Erlang的安装包 Erlang下载地址：http://www.rabbitmq.com/releases/erlang/ 下载的Erlang安装包为: erlang-19.0.4-1.el7.centos.x86_64.rpm RabbitMQ下载地址：https://www.rabbitmq.com/download.html 下载的RabbitMQ安装包为：rabbitmq-server-3.6.8-1.el7.noarch.rpm 1.安装Erlang 1yum install erlang-19.0.4-1.el7.centos.x86_64.rpm ​ 测试Erlang是否安装成功 1erl -version ​ 出现以下信息则表示安装成功 1Erlang (SMP,ASYNC_THREADS,HIPE) (BEAM) emulator version 8.0.3 2.安装RabbitMQ 1yum install rabbitmq-server-3.6.8-1.el7.noarch.rpm ​ 运行RabbitMQ 1service rabbitmq-server start ​ 停止RabbitMQ 1service rabbitmq-server stop 用户配置 添加用户 1rabbitmqctl add_user admin admin 添加管理员权限 1rabbitmqctl set_user_tags admin administrator 修改密码 1rabbitmqctl add_user admin youpassword 设置权限 1rabbitmqctl set_permissions -p '/' admin '.' '.' '.' 查看服务状态 1service rabbitmq-server status 启用WEB管理 启动web插件 1rabbitmq-plugins enable rabbitmq_management 访问地址http://IP:15672/ 删除guest用户 1rabbitmqctl delete_user guest 由于guest用户被限制，只能通过localhost访问，因此我们需要新建一个用户，并授予管理员权限 添加Web访问权限注意：rabbitmq从3.3.0开始禁止使用guest/guest权限通过除localhost外的访问。如果想使用guest/guest通过远程机器访问，需要在rabbitmq配置文件中(/etc/rabbitmq/rabbitmq.config)中设置loopback_users为[],配置文件不存在创建即可。 添加配置 1[&#123;rabbit, [&#123;loopback_users, [&quot;admin&quot;]&#125;]&#125;]]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ]]></title>
    <url>%2F2019%2F03%2F26%2FRocketMQ%2F</url>
    <content type="text"><![CDATA[rocketmq java 客户端调用No route info of this topic错误(原因版本不一致)https://blog.csdn.net/whhwkm/article/details/81783322]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ 详解]]></title>
    <url>%2F2019%2F03%2F26%2FRabbitMQ%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[分布式消息中间件场景介绍 ​ 背景 ​ 使用过分布式中间件的人都知道，程序员使用起来并不复杂，常用的客户端 API 就那么几个，比我们日常编写程序时用到的 API 要少得多。但是分布式中间件在中小研发团队中使用得并不多，为什么会这样呢？ ​ 原因是中间件的职责相对单一，客户端的使用虽然简单，但整个环境搭起来却不容易。 ​ 场景介绍 ​ 1、业务系统往往要求响应能力特别强，能够起到削峰填谷的作用 ​ 2、解耦：如果一个系统挂了，则不会影响另外个系统的继续运行 ​ 3、业务系统往往有对消息的高可靠要求，以及有对复杂功能如 Ack 的要求 ​ 4、增强业务系统的异步处理能力，减少甚至几乎不可能出现并发现象 使用消息队列，就好比为了防汛而建葛洲坝，有大量数据的堆积能力，然后可靠地进行异步输出 ​ RabbitMQ介绍 ​ RabbitMQ 是基于 AMQP 实现的一个开源消息组件，主要用于在分布式系统中存储转发消息，由因高性能、高可用以及高扩展而出名的 Erlang 语言写成 ​ 其中，AMQP（Advanced Message Queuing Protocol，即高级消息队列协议），是一个异步消息传递所使用的应用层协议规范，为面向消息的中间件设计 ​ RabbitMQ 特点 ​ 高可靠：RabbitMQ 提供了多种多样的特性让你在可靠性和性能之间做出权衡，包括持久化、发送应答、发布确认以及高可用性。 ​ 高可用队列：支持跨机器集群，支持队列安全镜像备份，消息的生产者与消费者不论哪一方出现问题，均不会影响消息的正常发出与接收。 ​ 灵活的路由：所有的消息都会通过路由器转发到各个消息队列中，RabbitMQ 内建了几个常用的路由器，并且可以通过路由器的组合以及自定义路由器插件来完成复杂的路由功能。 ​ 支持多客户端：对主流开发语言（如：Python、Ruby、.NET、Java、C、PHP、ActionScript 等）都有客户端实现。 ​ 集群：本地网络内的多个 Server 可以聚合在一起，共同组成一个逻辑上的 broker。 ​ 扩展性：支持负载均衡，动态增减服务器简单方便。 ​ 权限管理：灵活的用户角色权限管理，Virtual Host 是权限控制的最小粒度。 ​ 插件系统：支持各种丰富的插件扩展，同时也支持自定义插件，其中最常用的插件是 Web 管理工具 RabbitMQ_Management RabbitMQ 5种用法介绍 ​ RabbitMQ共有5种使用方式，即单对单、单对多、发布订阅模式、按路由规则发送接收、主题 ​ 1、单对单：单发送，单接收 ​ 适用于一个生产者，一个消费者的情况 ​ 2、单对多：单发送，多接收 ​ 适用于只有一个生产者，多个消费者，如分布式的任务派发 ​ 3、发布订阅模式：单发送，多接收 ​ 一个生产者发送消息，多个消费者获取消息（同样的消息），包括一个生产者，一个交换机，多个队列，多个消费者。 ​ 思路解读 ​ &gt; 一个生产者，多个消费者 ​ &gt; 每一个消费者都有自己的一个队列 ​ &gt; 生产者没有直接发消息到队列中，而是发送到交换机 ​ &gt; 每个消费者的队列都绑定到交换机上 ​ &gt; 消息通过交换机到达每个消费者的队列 ​ 注意：交换机没有存储消息功能，如果消息发送到没有绑定消费队列的交换机，消息则丢失 ​ 4、按路由规则发送接收： ​ 生产者发送消息到交换机并指定一个路由key，消费者队列绑定到交换机时要制定路由key（key匹配就能接受消息，key不匹配就不能接受消息），例如：我们可以把路由key设置为insert ，那么消费者队列key指定包含insert才可以接收消息，消费者队列key定义为update或者delete就不能接收消息。很好的控制了更新，插入和删除的操作。 ​ 5、主题： ​ Exchange Type 为 topic，发送消息时，需要指定交换机及Routing Key，消费者的消息队列绑定到该交换机并匹配到Routing Key实现消息的订阅，订阅后则可接收消息。只有消费者队列绑定到该交换机且指定的Routing Key符合匹配规则，才能收到消息。 ​ 其中Routing Key可以设置成通配符，如：* 或 #（* 表示匹配Routing Key中的某个单词，# 表示任意的Routing Key的消息都能被收到）。如果Routing Key由多个单词组成，则单词之间用 . 来分隔。 ​ 命名规范 ​ 交换机名的命名建议 ​ Ex{AppID}.{自定义 ExchangeName}，队列名的命名建议：MQ{AppID}.{自定义 QueueName} ​]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis主从部署]]></title>
    <url>%2F2018%2F12%2F14%2FRedis%E4%B8%BB%E4%BB%8E%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Redis主从部署 配置 redis目录下创建master、slave1、slave2三个目录，每个目录下分别创建一个redis.conf 修改slave的redis配置文件 12slaveof ip port(映射到主服务器上)masterauth pwd 分表启动master、slave1、slave2三个服务 在三个服务下分别执行info命令 master显示如下 slave显示如下 ​ 则三个服务启动成功 哨兵监控–可以自动切换故障主从 redis目录下创建sentinel1.conf、sentinel2.conf、sentinel3.conf、sentinel1.log、sentinel2.log、sentinel3.log sentinel.conf配置如下 12345678910111213141516#端口port **#后端启动daemonize yes #日志文件路径logfile &quot;/install/redis/redis-3.2.1/sentinel.log” #唯一id，选举时用到sentinel myid a36dd6517a54a4fb8f0e1024c3acaa16417652d0 id #监控redis主库sentinel monitor mymaster 127.0.0.1 6384 2#多久不回复心跳反应，则默认服务不可用redis sentinel down-after-milliseconds mymaster 5000#认证密码配置sentinel auth-pass mymaster 123456#保护模式关闭protected-mode no 分表启动三个哨兵sentinel.conf]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES部署]]></title>
    <url>%2F2018%2F12%2F02%2FES%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[ES部署 下载安装包 https://www.elastic.co/downloads/elasticsearch 解压运行 cd 到安装目录 sudo bin/elasticsearch 验证 浏览器中访问http://localhost:9200/看到一个json结果集，表明安装成功 切换root身份 ES不能以 root身份启动，需要添加用户组chown -R es:es es/ es:es把目录权限给es:es es需要调整参数。/etc/sysctl.conf 最后添加vm.max_map_count=655360 执行sysctl 配置 1234567891011cluster.namenode.namenode.master: true/falsepath.datapath.logsbootstrap.memory_lock: falsebootstrap.system_call_filter: falsehttp.porttransport.tcp.portdiscovery.zen.ping.unicast.hostsnode.max_local_storage_nodes]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 常用命令]]></title>
    <url>%2F2018%2F11%2F20%2FDocker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker 常用命令 查看正在运行的容器 1docker ps 查询项目 1sudo docker ps -a |grep 项目 进入容器 1sudo docker exec -it 项目名 bash 查看本地镜像 1docker images 查看指定容器的某个确定端口映射到宿主机的端口号 1docker port ID/NAMES 查看web应用程序的日志 1docker logs -f ID/NAMES 查看web应用程序容器内部运行的进程 1docker top ID/NAMES 已经停止的容器，可以使用命令 docker start 来启动 1docker start ID/NAMES 停止web应用程序容器 1docker stop ID/NAMES 查询最后一次创建的容器 1docker ps -l 删除不需要的容器 删除容器时，容器必须是停止状态，否则报错 1docker rm ID/NAMES 获取新镜像 1docker pull 名:版本（ubuntu:13.10） 查找镜像 1docker search 名 启动容器并进入容器 1docker run -t -i 名 /bin/bash]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jar debug 启动]]></title>
    <url>%2F2018%2F10%2F16%2FJar%20debug%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[debug启动脚本1java -jar -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005 ***.jar debug]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins 安装]]></title>
    <url>%2F2018%2F09%2F19%2FJenkins%20%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Jenkins 安装步骤 安装步骤 1.Install JDK 2.安装 Jenkins 仓库 12wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.reporpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key 3.安装 Jenkins 12yum install jenkins -y配置文件地址 /etc/sysconfig/jenkins 4.启动 jenkins 1systemctl start jenkins 5.查看初始化密码 1cat /var/lib/jenkins/secrets/initialAdminPassword 6.访问地址 1http://10.0.96.102:8080/ 7.配置Jdk、Maven ​ 配置JDK、Maven地址 ​ 安装maven Integration 插件 8.安装Git 1yum install git ​ 配置Git地址以及安装Git-Client插件 9.安装GitLab、GitLab Hook插件 10.配置全局凭据（拉取代码私钥） 11.shell启动springboot jar脚本 1234567891011121314151617#!/bin/bash# jenkins工作目录project_path=/var/lib/jenkins/workspace/eurekacd $&#123;project_path&#125;# 打包mvn clean package -Dmaven.test.skip=true jar_path=/var/lib/jenkins/workspace/eureka/target/jar_name=eureka-server-0.0.1-SNAPSHOT.jarcd $&#123;jar_path&#125;# 杀死进程ps -ef|grep eureka |grep -v grep |awk &apos;&#123;print $2&#125;&apos;|xargs kill -9# 启动服务BUILD_ID=dontKillMe nohup java -jar $&#123;jar_name&#125; &amp; War部署 1.下载jenkins.war文件,官网地址:http://jenkins-ci.org/ 注意选择最新版本Long-Term Support Release 2.访问地址http://IP:8080/jenkins/ 3.查看初始密码 1cat /root/.jenkins/secrets/initialAdminPassword 4.配置Jdk、Maven ​ 配置JDK、Maven地址 ​ 安装maven Integration 插件 5.安装Git 1yum install git ​ 配置Git地址以及安装Git-Client插件 6.安装GitLab、GitLab Hook插件 7.配置全局凭据（拉取代码私钥） 8.shell启动springboot jar脚本 123456789101112131415161718#!/bin/bash# jenkins工作目录project_path=/root/.jenkins/workspace/eurekacd $&#123;project_path&#125;# 打包mvn clean package -Dmaven.test.skip=true jar_path=/root/.jenkins/workspace/eureka/target/jar_name=eureka-server-0.0.1-SNAPSHOT.jarcd $&#123;jar_path&#125;# 杀死进程ps -ef|grep eureka |grep -v grep |awk &apos;&#123;print $2&#125;&apos;|xargs kill -9# 启动服务BUILD_ID=dontKillMe nohup java -jar $&#123;jar_name&#125; &amp;# 注意 BUILD_ID=dontKillMe 不加的话 会启动完成直接关闭服务]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql-emoji表情]]></title>
    <url>%2F2018%2F09%2F03%2FMysql-emoji%E8%A1%A8%E6%83%85%2F</url>
    <content type="text"><![CDATA[Mysql-emoji表情支持版本 大于5.5.3的Mysql版本才开始支持emoji表情 Mysql-emoji表情失败原因 普通的字符串或者表情都是占位3个字节，使用utf8足够用了，但是移动端的表情符号占位是4个字节，普通的utf8就不够用了，为了应对无线互联网的机遇和挑战、避免 emoji 表情符号带来的问题、涉及无线相关的 MySQL 数据库建议都提前采用 utf8mb4 字符集。Mysql 5.5.3之前的版本，仅支持的utf8为3字节的，Mysql 5.5.3之后的版本支持utf8mb4为4字节的。 Mysql配置修改 修改mysql配置文件my.cnf（windows为my.ini） 找到后请在以下三部分里添加如下内容 123456789[client] default-character-set = utf8mb4 [mysql] default-character-set = utf8mb4 [mysqld] character-set-client-handshake = FALSE character-set-server = utf8mb4 collation-server = utf8mb4_unicode_ci init_connect=&apos;SET NAMES utf8mb4&apos; 检查变量 1SHOW VARIABLES WHERE Variable_name LIKE &apos;character_set_%&apos; OR Variable_name LIKE &apos;collation%&apos;; 将数据库和已经建好的表也转换成utf8mb4 1.更改数据库编码 1ALTER DATABASE caitu99 CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 2.更改表编码 1ALTER TABLE TABLE_NAME CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM常用调试命令]]></title>
    <url>%2F2018%2F08%2F06%2FJVM%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[JVM常用调试命令 jps 虚拟机进程状况工具 1jps -v 输出虚拟机进程启动时jvm参数 包括 进程占用的端口号 jstat 虚拟机统计信息监视工具 1jstat -gcutil pid 1000 10 查询GC情况(1秒一次，统计10次) jmap java内存影像工具 1jmap -histo pid |grep xxx 根据端口号pid查询类实例信息 jstack java堆跟踪工具 1jstack -l pid 查看线程堆栈]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存参数设置]]></title>
    <url>%2F2018%2F07%2F25%2FJVM%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[JVM内存常用参数设置 堆内存 最大堆内存(新生代和老年代之和的最大值) -Xmx 最小堆内存(初始大小) -Xms 新生代大小 一般设置为整个堆内存的 1/3或者1/4 -Xmn等效于设置了-XX:NewSize与-XX:MaxNewSize相同大小 -XX:NewSize 设置新生代的初始大小 -XX:MaxNewSize设置新生代的最大值 ​ 设置不同的-XX:NewSize与-XX:MaxNewSize可能会导致内存震荡,以减少运行期间系统在内存申请上所花的开销 -XX:SurvivorRadio用来设置新生代eden空间与s0空间的比例关系 ​ s0与s1空间又分别称为from空间和to空间),并在Minor GC后会互换角色 ​ 常用比例eden:s0:s1 = 8:1:1 老年代大小 -XX:NewRadio用来设置老年代与新生代的比例(2:1/3:1) -Xss 用来设置线程栈的大小 方法区(持久代) HotSpot 虚拟机 -XX:MaxPermSize设置方法区的最大值;-XX:PermSize设置方法区的初始大小 ​ 一般设置为64MB已经可以满足绝大部分的应用程序工作,如果依然出现方法区溢出,可以将值设置为128MB若依然不能满足,则应该考虑优化程序设计]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存模型]]></title>
    <url>%2F2018%2F07%2F12%2FJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JVM内存模型 栈 ​ 栈分虚拟机栈和本地方法栈 ​ 栈用来存储Java的基本数据类型. Java指令代码(包括方法). 常量 Stack的内存管理是顺序分配的，而且定长,不存在内存回收的问题 堆 ​ 堆用来存储Java对象实例 实际上也是保存对象实例的属性值，属性的类型和对象本身的类型标记等Heap 则是随机分配内存，不定长度，存在内存分配和回收的问题 ​ 注意:对象实例在Heap 中分配好以后，需要在Stack中保存一个4字节的Heap 内存地址，用来定位该对象实例在Heap 中的位置，便于找到该对象实例 方法区 ​ 所有**线程共享**的内存区域 ​ 存储已被虚拟机加载的类信息.常量.静态变量，运行时的常量池也存于方法区中 程序计数器 ​ 当前线程所执行的字节码的行号指示器 ​ 执行的是java方法时,计数器记录的是正在执行的虚拟机字节码指令的地址. ​ 执行的是Native方法,计数器值为空 其中方法区和堆是线程共享的数据区；其他区域是线程隔离的数据区]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM类加载机制]]></title>
    <url>%2F2018%2F06%2F21%2FJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[上级委托加载机制 1.整个JVM平台提供三层ClassLoader Bootstrap ClassLoader 主要加载JVM自身工作需要的类 ,完全由JVM控制,一个类加载工具,没有高一级的父类加载器,也没用子加载器 没有遵守ClassLoader加载规则 ExtClassLoader 标准扩展类加载器 没父 AppClassLoader 父类是ExtClassLoader classpath目录下的类都可以被这个加载器加载 注意: ​ 1.如果要实现自己的类加载器,不管你是直接实现抽象类ClassLoader,还是继承URLClassLoader类,或者其他子类,它的父加载器都是AppClassLoader. ​ 2.在应用中能提取到的顶层父类是ExtClassLoader 2.JVM加载.class文件的过程 找到 .class文件,并把该文件包含的字节码加载到内存中. 字节码验证,Class类数据结构分析及相应的内存分配和最后的符号表的链接 类中静态属性和初始化赋值,以及静态块的执行]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾回收机制]]></title>
    <url>%2F2018%2F06%2F02%2FJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[垃圾回收机制 堆分为 新生代(Young) 与 老年代(Old) Young区 分为Eden区和两个Survivor区 ​ 新创建的对象都在Eden区,当Eden区满后会触发Minor GC,把Eden区回收后仍然存活的对象复制到其中一个空的Survivor区; 同时,另一个Survivor区中存活的对象也复制到这个Survivor中,保证总有一个Survivor区是空的 Old区 ​ Young的Eden区满后会触发Minor GC,把Eden区回收后仍存活的对象放到Survivor区中,如果此时Survivor区仍然存不下这些存活的对象,GC收集器会把这些对象直接存放到Old区;如果在Survivor区中的对象足够老,也直接放到Old区.如果Old区也满了,则触发Full GC,回收整个堆内存 Perm区 ​ 存放的主要是类的Class对象, 垃圾回收也是由Full GC触发 垃圾回收算法 标记-清除算法 ​ 对于每个存活的对象,进行标记.标记完成,开始进行清理(未标记)不再存活的对象 ​ 缺点:产生过多碎片,导致内存不连续,分配大对象时,无法找到足够的内存触发gc，效率不是太高 复制算法 ​ 用于生存率较低的场景 把内存分为若干个区域,每次只使用其中一部分,对于存货的对象,copy到另一个区域,对于剩余的对象进行垃圾回收 ​ 缺点:造成内存浪费 ​ 优点: 无碎片 标记-整理算法 ​ 类似于标记清理,后续不是直接对对象进行清理,而是进行移动存活对象,边界外进行清除 JVM采用分代的垃圾回收算法 新生代 死的快,存活率低 采用 复制算法 Minor GC 老年代 存活长 采用标记清理 Full GC]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vi编辑器]]></title>
    <url>%2F2018%2F05%2F26%2Fvi%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1、vi 文件名 2、输入 i 进入编辑模式 3、对文件进行编辑 4、Esc 退出编辑模式，进入命令模式 5、:wq 保存退出 ​ :q! 退出但不保存 配置 vimrc 当我最初使用 vim 的时候，我浪费了好多时间来缩进代码，我不知道通过修改 Vim 的 .vimrc 配置文件来实现代码缩进、语法高亮、显示行号等功能。 在你的 Home 目录下创建一个 .vimrc 文件，添加下面的代码来设置行号、代码缩进等 set number # 显示行号 set autoindent # 自动缩进 set nowrap # 不换行 不关闭终端退出编辑器 使用 Vim 编辑器保存并退出编辑状态是一件轻而易举的事，你只需记住按 ESC 键切换到正常模式，然后输入冒号(:)，之后输入 wq 即可实现保存并退出。 :wq 如果不想保存，则按 ESC 键切换到正常模式，然后输入冒号(:)，之后输入 q! 即可。 :q! 删除一行或多行 通过退格键(Backspace)来删除一行代码显然是太麻烦了。可以通过切换到正常模式(编辑模式下按 ESC 键)来进行操作 dd ： (输入两次 d，下同)删除当前行；5dd ：删除当前行开始的5行； dG ：(先输入d，然后按 shift 键输入 g)删除当前行至最后一行的所以行。 复制粘贴一块代码 你可能经常需要复制一行或一大块代码，使用 Vim 快捷键来实现此功能是非常简单的 按 Esc 切换到正常模式； 把光标移到你需要复制的代码行首； 按 V 选择整行，可移动光标选择多行； 按 d 剪切或按 y 复制选择的代码； 移动光标到你需要粘贴的位置，按 p 粘贴代码到光标后的位置，或按 P 粘贴到光标前。 撤销与重做 在使用 Vim 或其他编辑器的时候，你可能经常需要对某些修改进行撤销或重做。在 Vim 中，你可以切换到正常模式，按 u 来撤销操作，按 Ctrl+r 来重做 搜索 搜索在很多时候都是一个非常重要的功能。在文件中搜索一个特定的词，可以切换到正常模式，然后输入斜线( / )，之后跟上要搜索的词，回车即可 /word-to-be-searched 按 n 显示下一个搜索结果，按 N 显示上一个搜索结果 把外部文件读入 Vim 我开始使用 Vim 的时候，经常会打开一个文件、复制内容、关闭文件、打开另一个文件、然后粘贴进去复制到内容。其实 Vim 中读取另一个文件的内容非常方便。切换到正常模式，然后按 :read。使用此快捷键你不需要手动打开文件来复制内容 :read readme.md 把命令的结果读入 Vim 有时候你需要把某个命令的结果复制到 Vim 中，这在 Vim 也非常简单。切换到正常模式，然后输入 :read !command 即可把 command 的结果输入到 vim 中 :read !ls -l 切换到上次修改的位置 想知道你在文件中做的最后一次修改是在什么位置？切换到正常模式，输入 g; 来即可切换到上次修改的位置 移动到文件顶部或底部 当需要移动到文件顶部或底部时，通过 j 或 k 来一行行的移动显得有点麻烦。Vim 提供了一个快捷键可直接实现此功能。切换到正常模式，输入 gg 返回文件顶部，输入 G 返回文件底部]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F26%2FHello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hello</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
</search>
